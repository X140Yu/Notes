{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to MkDocs\n\n\nFor full documentation visit \nmkdocs.org\n.\n\n\nCommands\n\n\n\n\nmkdocs new [dir-name]\n - Create a new project.\n\n\nmkdocs serve\n - Start the live-reloading docs server.\n\n\nmkdocs build\n - Build the documentation site.\n\n\nmkdocs help\n - Print this help message.\n\n\n\n\nProject layout\n\n\nmkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.",
            "title": "Home"
        },
        {
            "location": "/#welcome-to-mkdocs",
            "text": "For full documentation visit  mkdocs.org .",
            "title": "Welcome to MkDocs"
        },
        {
            "location": "/#commands",
            "text": "mkdocs new [dir-name]  - Create a new project.  mkdocs serve  - Start the live-reloading docs server.  mkdocs build  - Build the documentation site.  mkdocs help  - Print this help message.",
            "title": "Commands"
        },
        {
            "location": "/#project-layout",
            "text": "mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.",
            "title": "Project layout"
        },
        {
            "location": "/swift/reactive-swift/",
            "text": "Design Guidelines\n\n\nThis document contains guidelines for projects that want to make use of\nReactiveSwift. The content here is heavily inspired by the \nRx Design\nGuidelines\n.\n\n\nThis document assumes basic familiarity\nwith the features of ReactiveSwift. The \nFramework Overview\n is a better\nresource for getting up to speed on the main types and concepts provided by ReactiveSwift.\n\n\nThe \nEvent\n contract\n\n\n\n\nvalue\ns provide values or indicate the occurrence of events\n\n\nfailure\ns behave like exceptions and propagate immediately\n\n\ncompletion\n indicates success\n\n\ninterruption\ns cancel outstanding work and usually propagate immediately\n\n\nEvents are serial\n\n\nEvents are never delivered recursively, and values cannot be sent recursively\n\n\nEvents are sent synchronously by default\n\n\n\n\nThe \nSignal\n contract\n\n\n\n\nSignals start work when instantiated\n\n\nObserving a signal does not have side effects\n\n\nAll observers of a signal see the same events in the same order\n\n\nA signal is alive as long as it is publicly reachable or is being observed\n\n\nTerminating events dispose of signal resources\n\n\n\n\nThe \nSignalProducer\n contract\n\n\n\n\nSignal producers start work on demand by creating signals\n\n\nEach produced signal may send different events at different times\n\n\nSignal operators can be lifted to apply to signal producers\n\n\nDisposing of a produced signal will interrupt it\n\n\n\n\nThe Property contract\n\n\n\n\nA property must have its latest value sent synchronously accessible\n\n\nEvents must be synchronously emitted after the mutation is visible\n\n\nReentrancy must be supported for reads\n\n\nA composed property does not have a side effect on its sources, and does not own its lifetime\n\n\n\n\nBest practices\n\n\n\n\nProcess only as many values as needed\n\n\nObserve events on a known scheduler\n\n\nSwitch schedulers in as few places as possible\n\n\nCapture side effects within signal producers\n\n\nShare the side effects of a signal producer by sharing one produced signal\n\n\nPrefer managing lifetime with operators over explicit disposal\n\n\n\n\nImplementing new operators\n\n\n\n\nPrefer writing operators that apply to both signals and producers\n\n\nCompose existing operators when possible\n\n\nForward failure and interruption events as soon as possible\n\n\nSwitch over \nEvent\n values\n\n\nAvoid introducing concurrency\n\n\nAvoid blocking in operators\n\n\n\n\nThe \nEvent\n contract\n\n\nEvents\n are fundamental to ReactiveSwift. \nSignals\n and \nsignal producers\n both send\nevents, and may be collectively called \u201cevent streams.\u201d\n\n\nEvent streams must conform to the following grammar:\n\n\nvalue* (interrupted | failed | completed)?\n\n\n\n\nThis states that an event stream consists of:\n\n\n\n\nAny number of \nvalue\n events\n\n\nOptionally followed by one terminating event, which is any of \ninterrupted\n, \nfailed\n, or \ncompleted\n\n\n\n\nAfter a terminating event, no other events will be received.\n\n\nvalue\ns provide values or indicate the occurrence of events\n\n\nvalue\n events contain a payload known as the \u201cvalue\u201d. Only \nvalue\n events are\nsaid to have a value. Since an event stream can contain any number of \nvalue\ns,\nthere are few restrictions on what those values can mean or be used for, except\nthat they must be of the same type.\n\n\nAs an example, the value might represent an element from a collection, or\na progress update about some long-running operation. The value of a \nvalue\n event\nmight even represent nothing at all\u2014for example, it\u2019s common to use a value type\nof \n()\n to indicate that something happened, without being more specific about\nwhat that something was.\n\n\nMost of the event stream \noperators\n act upon \nvalue\n events, as they represent the\n\u201cmeaningful data\u201d of a signal or producer.\n\n\nfailure\ns behave like exceptions and propagate immediately\n\n\nfailed\n events indicate that something went wrong, and contain a concrete error\nthat indicates what happened. Failures are fatal, and propagate as quickly as\npossible to the consumer for handling.\n\n\nFailures also behave like exceptions, in that they \u201cskip\u201d operators, terminating\nthem along the way. In other words, most \noperators\n immediately stop doing\nwork when a failure is received, and then propagate the failure onward. This even applies to time-shifted operators, like \ndelay\n\u2014which, despite its name, will forward any failures immediately.\n\n\nConsequently, failures should only be used to represent \u201cabnormal\u201d termination. If it is important to let operators (or consumers) finish their work, a \nvalue\n\nevent describing the result might be more appropriate.\n\n\nIf an event stream can \nnever\n fail, it should be parameterized with the\nspecial \nNoError\n type, which statically guarantees that a \nfailed\n\nevent cannot be sent upon the stream.\n\n\ncompletion\n indicates success\n\n\nAn event stream sends \ncompleted\n when the operation has completed successfully,\nor to indicate that the stream has terminated normally.\n\n\nMany operators manipulate the \ncompleted\n event to shorten or extend the\nlifetime of an event stream.\n\n\nFor example, \ntake\n will complete after the specified number of values have\nbeen received, thereby terminating the stream early. On the other hand, most\noperators that accept multiple signals or producers will wait until \nall\n of\nthem have completed before forwarding a \ncompleted\n event, since a successful\noutcome will usually depend on all the inputs.\n\n\ninterruption\ns cancel outstanding work and usually propagate immediately\n\n\nAn \ninterrupted\n event is sent when an event stream should cancel processing.\nInterruption is somewhere between \nsuccess\n\nand \nfailure\n\u2014the\noperation was not successful, because it did not get to finish, but it didn\u2019t\nnecessarily \u201cfail\u201d either.\n\n\nMost \noperators\n will propagate interruption immediately, but there are some\nexceptions. For example, the \nflattening operators\n will ignore\n\ninterrupted\n events that occur on the \ninner\n producers, since the cancellation\nof an inner operation should not necessarily cancel the larger unit of work.\n\n\nReactiveSwift will automatically send an \ninterrupted\n event upon \ndisposal\n, but it can\nalso be sent manually if necessary. Additionally, \ncustom\noperators\n must make sure to forward interruption\nevents to the observer.\n\n\nEvents are serial\n\n\nReactiveSwift guarantees that all events upon a stream will arrive serially. In other\nwords, it\u2019s impossible for the observer of a signal or producer to receive\nmultiple \nEvent\ns concurrently, even if the events are sent on multiple threads\nsimultaneously.\n\n\nThis simplifies \noperator\n implementations and \nobservers\n.\n\n\nEvents are never delivered recursively, and values cannot be sent recursively.\n\n\nJust like \nthe guarantee of events not being delivered\nconcurrently\n, it is also guaranteed that events would not be\ndelivered recursively. As a consequence, \noperators\n and \nobservers\n \ndo not\n need to\nbe reentrant.\n\n\nIf a \nvalue\n event is sent upon a signal from a thread that is \nalready processing\n\na previous event from that signal, it would result in a deadlock. This is because\nrecursive signals are usually programmer error, and the determinacy of\na deadlock is preferable to nondeterministic race conditions.\n\n\nNote that a terminal event is permitted to be sent recursively.\n\n\nWhen a recursive signal is explicitly desired, the recursive event should be\ntime-shifted, with an operator like \ndelay\n, to ensure that it isn\u2019t sent from\nan already-running event handler.\n\n\nEvents are sent synchronously by default\n\n\nReactiveSwift does not implicitly introduce concurrency or asynchrony. \nOperators\n that\naccept a \nscheduler\n may, but they must be explicitly invoked by the consumer of\nthe framework.\n\n\nA \u201cvanilla\u201d signal or producer will send all of its events synchronously by\ndefault, meaning that the \nobserver\n will be synchronously invoked for each event\nas it is sent, and that the underlying work will not resume until the event\nhandler finishes.\n\n\nThis is similar to how \nNSNotificationCenter\n or \nUIControl\n events are\ndistributed.\n\n\nThe \nSignal\n contract\n\n\nA \nsignal\n is a stream of values that obeys \nthe \nEvent\n contract\n.\n\n\nSignal\n is a reference type, because each signal has identity \u2014 in other words, each\nsignal has its own lifetime, and may eventually terminate. Once terminated,\na signal cannot be restarted.\n\n\nSignals start work when instantiated\n\n\nSignal.init\n immediately executes the generator closure that is passed to it.\nThis means that side effects may occur even before the initializer returns.\n\n\nIt is also possible to send \nevents\n before the initializer returns. However,\nsince it is impossible for any \nobservers\n to be attached at this point, any\nevents sent this way cannot be received.\n\n\nObserving a signal does not have side effects\n\n\nThe work associated with a \nSignal\n does not start or stop when \nobservers\n are\nadded or removed, so the \nobserve\n method (or the cancellation thereof) never\nhas side effects.\n\n\nA signal\u2019s side effects can only be stopped through \na terminating event\n, or by a silent disposal at the point that \nthe signal is neither publicly reachable nor being observed\n.\n\n\nAll observers of a signal see the same events in the same order\n\n\nBecause \nobservation does not have side\neffects\n, a \nSignal\n never\ncustomizes events for different \nobservers\n. When an event is sent upon a signal,\nit will be \nsynchronously\n\ndistributed to all observers that are attached at that time, much like\nhow \nNSNotificationCenter\n sends notifications.\n\n\nIn other words, there are not different event \u201ctimelines\u201d per observer. All\nobservers effectively see the same stream of events.\n\n\nThere is one exception to this rule: adding an observer to a signal \nafter\n it\nhas already terminated will result in exactly one\n\ninterrupted\n\nevent sent to that specific observer.\n\n\nA signal is alive as long as it is publicly reachable or is being observed\n\n\nA \nSignal\n must be publicly retained for attaching new observers, but not\nnecessarily for keeping the stream of events alive. Moreover, a \nSignal\n retains\nitself as long as there is still an active observer.\n\n\nIn other words, if a \nSignal\n is neither publicly retained nor being observed,\nit would dispose of the signal resources silently.\n\n\nNote that the input observer of a signal does not retain the signal itself.\n\n\nLong-running side effects are recommended to be modeled as an observer to the\nsignal.\n\n\nTerminating events dispose of signal resources\n\n\nWhen a terminating \nevent\n is sent along a \nSignal\n, all \nobservers\n will be\nreleased, and any resources being used to generate events should be disposed of.\n\n\nThe easiest way to ensure proper resource cleanup is to return a \ndisposable\n\nfrom the generator closure, which will be disposed of when termination occurs.\nThe disposable should be responsible for releasing memory, closing file handles,\ncanceling network requests, or anything else that may have been associated with\nthe work being performed.\n\n\nThe \nSignalProducer\n contract\n\n\nA \nsignal producer\n is like a \u201crecipe\u201d for creating\n\nsignals\n. Signal producers do not do anything by themselves\u2014\nwork begins only\nwhen a signal is produced\n.\n\n\nSince a signal producer is just a declaration of \nhow\n to create signals, it is\na value type, and has no memory management to speak of.\n\n\nSignal producers start work on demand by creating signals\n\n\nThe \nstart\n and \nstartWithSignal\n methods each\nproduce a \nSignal\n (implicitly and explicitly, respectively). After\ninstantiating the signal, the closure that was passed to\n\nSignalProducer.init\n will be executed, to start the flow\nof \nevents\n after any observers have been attached.\n\n\nAlthough the producer itself is not \nreally\n responsible for the execution of\nwork, it\u2019s common to speak of \u201cstarting\u201d and \u201ccanceling\u201d a producer. These terms\nrefer to producing a \nSignal\n that will start work, and \ndisposing of that\nsignal\n to stop work.\n\n\nA producer can be started any number of times (including zero), and the work\nassociated with it will execute exactly that many times as well.\n\n\nEach produced signal may send different events at different times\n\n\nBecause signal producers \nstart work on\ndemand\n, there may\nbe different \nobservers\n associated with each execution, and those observers\nmay see completely different \nevent\n timelines.\n\n\nIn other words, events are generated from scratch for each time the producer is\nstarted, and can be completely different (or in a completely different order)\nfrom other times the producer is started.\n\n\nNonetheless, each execution of a signal producer will follow \nthe \nEvent\n\ncontract\n.\n\n\nSignal operators can be lifted to apply to signal producers\n\n\nDue to the relationship between signals and signal producers, it is possible to\nautomatically promote any \noperators\n over one or more \nSignal\ns to apply to\nthe same number of \nSignalProducer\ns instead, using the \nlift\n method.\n\n\nlift\n will apply the behavior of the specified operator to each \nSignal\n that\nis \ncreated when the signal producer is started\n.\n\n\nDisposing of a produced signal will interrupt it\n\n\nWhen a producer is started using the \nstart\n or\n\nstartWithSignal\n methods, a \nDisposable\n is\nautomatically created and passed back.\n\n\nDisposing of this object will\n\ninterrupt\n\nthe produced \nSignal\n, thereby canceling outstanding work and sending an\n\ninterrupted\n \nevent\n to all \nobservers\n, and will also dispose of\neverything added to the \nCompositeDisposable\n in\n\nSignalProducer.init\n.\n\n\nNote that disposing of one produced \nSignal\n will not affect other signals created\nby the same \nSignalProducer\n.\n\n\nThe Property contract.\n\n\nA property is essentially a \nSignal\n which guarantees it has an initial value, and its latest value is always available for being read out.\n\n\nAll read-only property types should conform to \nPropertyProtocol\n, while the mutable counterparts should conform to \nMutablePropertyProtocol\n. ReactiveSwift includes two primitives that implement the contract: \nProperty\n and \nMutableProperty\n.\n\n\nA property must have its latest value sent synchronously accessible.\n\n\nA property must have its latest value cached or stored at any point of time. It must be synchronously accessible through \nPropertyProtocol.value\n.\n\n\nThe \nSignalProducer\n of a property must replay the latest value before forwarding subsequent changes, and it may ensure that no race condition exists between the replaying and the setup of the forwarding.\n\n\nEvents must be synchronously emitted after the mutation is visible.\n\n\nA mutable property must emit its values and the \ncompleted\n event synchronously.\n\n\nThe observers of a property should always observe the same value from the signal and the producer as  \nPropertyProtocol.value\n. This implies that all observations are a \ndidSet\n observer.\n\n\nReentrancy must be supported for reads.\n\n\nAll properties must guarantee that observers reading \nPropertyProtocol.value\n would not deadlock.\n\n\nIn other words, if a mutable property type implements its own, or inherits a synchronization mechanism from its container, the synchronization generally should be reentrant due to the requirements of synchrony.\n\n\nA composed property does not have a side effect on its sources, and does not own its lifetime.\n\n\nA composed property presents a transformed view of its sources. It should not have a side effect on them, as \nobserving a signal does not have side effects\n either. This implies a composed property should never retain its sources, or otherwise the \ncompleted\n event emitted upon deinitialization would be influenced.\n\n\nMoreover, it does not own its lifetime, and its deinitialization should not affect its signal and its producer. The signal and the producer should respect the lifetime of the ultimate sources in a property composition graph.\n\n\nBest practices\n\n\nThe following recommendations are intended to help keep ReactiveSwift-based code\npredictable, understandable, and performant.\n\n\nThey are, however, only guidelines. Use best judgement when determining whether\nto apply the recommendations here to a given piece of code.\n\n\nProcess only as many values as needed\n\n\nKeeping an event stream alive longer than necessary can waste CPU and memory, as\nunnecessary work is performed for results that will never be used.\n\n\nIf only a certain number of values or certain number of time is required from\na \nsignal\n or \nproducer\n, operators like\n\ntake\n or \ntakeUntil\n can be used to\nautomatically complete the stream once a certain condition is fulfilled.\n\n\nThe benefit is exponential, too, as this will terminate dependent operators\nsooner, potentially saving a significant amount of work.\n\n\nObserve events on a known scheduler\n\n\nWhen receiving a \nsignal\n or \nproducer\n from unknown\ncode, it can be difficult to know which thread \nevents\n will arrive upon. Although\nevents are \nguaranteed to be serial\n, sometimes stronger\nguarantees are needed, like when performing UI updates (which must occur on the\nmain thread).\n\n\nWhenever such a guarantee is important, the \nobserveOn\n\n\noperator\n should be used to force events to be received upon\na specific \nscheduler\n.\n\n\nSwitch schedulers in as few places as possible\n\n\nNotwithstanding the \nabove\n, \nevents\n\nshould only be delivered to a specific \nscheduler\n when absolutely\nnecessary. Switching schedulers can introduce unnecessary delays and cause an\nincrease in CPU load.\n\n\nGenerally, \nobserveOn\n should only be used right before observing\nthe \nsignal\n, starting the \nproducer\n, or binding to\na \nproperty\n. This ensures that events arrive on the expected\nscheduler, without introducing multiple thread hops before their arrival.\n\n\nCapture side effects within signal producers\n\n\nBecause \nsignal producers start work on\ndemand\n, any\nfunctions or methods that return a \nsignal producer\n should\nmake sure that side effects are captured \nwithin\n the producer itself, instead\nof being part of the function or method call.\n\n\nFor example, a function like this:\n\n\nfunc search(text: String) -> SignalProducer<Result, NetworkError>\n\n\n\n\n\u2026 should \nnot\n immediately start a search.\n\n\nInstead, the returned producer should execute the search once for every time\nthat it is started. This also means that if the producer is never started,\na search will never have to be performed either.\n\n\nShare the side effects of a signal producer by sharing one produced signal\n\n\nIf multiple \nobservers\n are interested in the results of a \nsignal\nproducer\n, calling \nstart\n once for each observer\nmeans that the work associated with the producer will \nexecute that many\ntimes\n and \nmay not\ngenerate the same results\n.\n\n\nIf:\n\n\n\n\nthe observers need to receive the exact same results\n\n\nthe observers know about each other, or\n\n\nthe code starting the producer knows about each observer\n\n\n\n\n\u2026 it may be more appropriate to start the producer \njust once\n, and share the\nresults of that one \nsignal\n to all observers, by attaching them within\nthe closure passed to the \nstartWithSignal\n method.\n\n\nPrefer managing lifetime with operators over explicit disposal\n\n\nAlthough the \ndisposable\n returned from \nstart\n makes\ncanceling a \nsignal producer\n really easy, explicit use of\ndisposables can quickly lead to a rat's nest of resource management and cleanup\ncode.\n\n\nThere are almost always higher-level \noperators\n that can be used instead of manual\ndisposal:\n\n\n\n\ntake\n can be used to automatically terminate a stream once a certain\n   number of values have been received.\n\n\ntakeUntil\n can be used to automatically terminate\n   a \nsignal\n or producer when an event occurs (for example, when\n   a \u201cCancel\u201d button is pressed in the UI).\n\n\nProperties\n and the \n<~\n operator can be used to \u201cbind\u201d the result of\n   a signal or producer, until termination or until the property is deallocated.\n   This can replace a manual observation that sets a value somewhere.\n\n\n\n\nImplementing new operators\n\n\nReactiveSwift provides a long list of built-in \noperators\n that should cover most use\ncases; however, ReactiveSwift is not a closed system. It's entirely valid to implement\nadditional operators for specialized uses, or for consideration in ReactiveSwift\nitself.\n\n\nImplementing a new operator requires a careful attention to detail and a focus\non simplicity, to avoid introducing bugs into the calling code.\n\n\nThese guidelines cover some of the common pitfalls and help preserve the\nexpected API contracts. It may also help to look at the implementations of\nexisting \nSignal\n and \nSignalProducer\n operators for reference points.\n\n\nPrefer writing operators that apply to both signals and producers\n\n\nSince any \nsignal operator can apply to signal\nproducers\n,\nwriting custom operators in terms of \nSignal\n means that\n\nSignalProducer\n will get it \u201cfor free.\u201d\n\n\nEven if the caller only needs to apply the new operator to signal producers at\nfirst, this generality can save time and effort in the future.\n\n\nOf course, some capabilities \nrequire\n producers (for example, any retrying or\nrepeating), so it may not always be possible to write a signal-based version\ninstead.\n\n\nCompose existing operators when possible\n\n\nConsiderable thought has been put into the operators provided by ReactiveSwift, and they\nhave been validated through automated tests and through their real world use in\nother projects. An operator that has been written from scratch may not be as\nrobust, or might not handle a special case that the built-in operators are aware\nof.\n\n\nTo minimize duplication and possible bugs, use the provided operators as much as\npossible in a custom operator implementation. Generally, there should be very\nlittle code written from scratch.\n\n\nForward failure and interruption events as soon as possible\n\n\nUnless an operator is specifically built to handle\n\nfailures\n and\n\ninterruptions\n\nin a custom way, it should propagate those events to the observer as soon as\npossible, to ensure that their semantics are honored.\n\n\nSwitch over \nEvent\n values\n\n\nCreate your own \nobserver\n to process raw \nEvent\n values, and use\na \nswitch\n statement to determine the event type.\n\n\nFor example:\n\n\nproducer.start { event in\n    switch event {\n    case let .Next(value):\n        print(\"Next event: \\(value)\")\n\n    case let .Failed(error):\n        print(\"Failed event: \\(error)\")\n\n    case .Completed:\n        print(\"Completed event\")\n\n    case .Interrupted:\n        print(\"Interrupted event\")\n    }\n}\n\n\n\n\nSince the compiler will generate a warning if the \nswitch\n is missing any case,\nthis prevents mistakes in a custom operator\u2019s event handling.\n\n\nAvoid introducing concurrency\n\n\nConcurrency is an extremely common source of bugs in programming. To minimize\nthe potential for deadlocks and race conditions, operators should not\nconcurrently perform their work.\n\n\nCallers always have the ability to \nobserve events on a specific\nscheduler\n, and ReactiveSwift offers built-in ways\nto parallelize work, so custom operators don\u2019t need to be concerned with it.\n\n\nAvoid blocking in operators\n\n\nSignal or producer operators should return a new signal or producer\n(respectively) as quickly as possible. Any work that the operator needs to\nperform should be part of the event handling logic, \nnot\n part of the operator\ninvocation itself.\n\n\nThis guideline can be safely ignored when the purpose of an operator is to\nsynchronously retrieve one or more values from a stream, like \nsingle()\n or\n\nwait()\n.",
            "title": "ReactiveSwift"
        },
        {
            "location": "/swift/reactive-swift/#design-guidelines",
            "text": "This document contains guidelines for projects that want to make use of\nReactiveSwift. The content here is heavily inspired by the  Rx Design\nGuidelines .  This document assumes basic familiarity\nwith the features of ReactiveSwift. The  Framework Overview  is a better\nresource for getting up to speed on the main types and concepts provided by ReactiveSwift.  The  Event  contract   value s provide values or indicate the occurrence of events  failure s behave like exceptions and propagate immediately  completion  indicates success  interruption s cancel outstanding work and usually propagate immediately  Events are serial  Events are never delivered recursively, and values cannot be sent recursively  Events are sent synchronously by default   The  Signal  contract   Signals start work when instantiated  Observing a signal does not have side effects  All observers of a signal see the same events in the same order  A signal is alive as long as it is publicly reachable or is being observed  Terminating events dispose of signal resources   The  SignalProducer  contract   Signal producers start work on demand by creating signals  Each produced signal may send different events at different times  Signal operators can be lifted to apply to signal producers  Disposing of a produced signal will interrupt it   The Property contract   A property must have its latest value sent synchronously accessible  Events must be synchronously emitted after the mutation is visible  Reentrancy must be supported for reads  A composed property does not have a side effect on its sources, and does not own its lifetime   Best practices   Process only as many values as needed  Observe events on a known scheduler  Switch schedulers in as few places as possible  Capture side effects within signal producers  Share the side effects of a signal producer by sharing one produced signal  Prefer managing lifetime with operators over explicit disposal   Implementing new operators   Prefer writing operators that apply to both signals and producers  Compose existing operators when possible  Forward failure and interruption events as soon as possible  Switch over  Event  values  Avoid introducing concurrency  Avoid blocking in operators",
            "title": "Design Guidelines"
        },
        {
            "location": "/swift/reactive-swift/#the-event-contract",
            "text": "Events  are fundamental to ReactiveSwift.  Signals  and  signal producers  both send\nevents, and may be collectively called \u201cevent streams.\u201d  Event streams must conform to the following grammar:  value* (interrupted | failed | completed)?  This states that an event stream consists of:   Any number of  value  events  Optionally followed by one terminating event, which is any of  interrupted ,  failed , or  completed   After a terminating event, no other events will be received.",
            "title": "The Event contract"
        },
        {
            "location": "/swift/reactive-swift/#values-provide-values-or-indicate-the-occurrence-of-events",
            "text": "value  events contain a payload known as the \u201cvalue\u201d. Only  value  events are\nsaid to have a value. Since an event stream can contain any number of  value s,\nthere are few restrictions on what those values can mean or be used for, except\nthat they must be of the same type.  As an example, the value might represent an element from a collection, or\na progress update about some long-running operation. The value of a  value  event\nmight even represent nothing at all\u2014for example, it\u2019s common to use a value type\nof  ()  to indicate that something happened, without being more specific about\nwhat that something was.  Most of the event stream  operators  act upon  value  events, as they represent the\n\u201cmeaningful data\u201d of a signal or producer.",
            "title": "values provide values or indicate the occurrence of events"
        },
        {
            "location": "/swift/reactive-swift/#failures-behave-like-exceptions-and-propagate-immediately",
            "text": "failed  events indicate that something went wrong, and contain a concrete error\nthat indicates what happened. Failures are fatal, and propagate as quickly as\npossible to the consumer for handling.  Failures also behave like exceptions, in that they \u201cskip\u201d operators, terminating\nthem along the way. In other words, most  operators  immediately stop doing\nwork when a failure is received, and then propagate the failure onward. This even applies to time-shifted operators, like  delay \u2014which, despite its name, will forward any failures immediately.  Consequently, failures should only be used to represent \u201cabnormal\u201d termination. If it is important to let operators (or consumers) finish their work, a  value \nevent describing the result might be more appropriate.  If an event stream can  never  fail, it should be parameterized with the\nspecial  NoError  type, which statically guarantees that a  failed \nevent cannot be sent upon the stream.",
            "title": "failures behave like exceptions and propagate immediately"
        },
        {
            "location": "/swift/reactive-swift/#completion-indicates-success",
            "text": "An event stream sends  completed  when the operation has completed successfully,\nor to indicate that the stream has terminated normally.  Many operators manipulate the  completed  event to shorten or extend the\nlifetime of an event stream.  For example,  take  will complete after the specified number of values have\nbeen received, thereby terminating the stream early. On the other hand, most\noperators that accept multiple signals or producers will wait until  all  of\nthem have completed before forwarding a  completed  event, since a successful\noutcome will usually depend on all the inputs.",
            "title": "completion indicates success"
        },
        {
            "location": "/swift/reactive-swift/#interruptions-cancel-outstanding-work-and-usually-propagate-immediately",
            "text": "An  interrupted  event is sent when an event stream should cancel processing.\nInterruption is somewhere between  success \nand  failure \u2014the\noperation was not successful, because it did not get to finish, but it didn\u2019t\nnecessarily \u201cfail\u201d either.  Most  operators  will propagate interruption immediately, but there are some\nexceptions. For example, the  flattening operators  will ignore interrupted  events that occur on the  inner  producers, since the cancellation\nof an inner operation should not necessarily cancel the larger unit of work.  ReactiveSwift will automatically send an  interrupted  event upon  disposal , but it can\nalso be sent manually if necessary. Additionally,  custom\noperators  must make sure to forward interruption\nevents to the observer.",
            "title": "interruptions cancel outstanding work and usually propagate immediately"
        },
        {
            "location": "/swift/reactive-swift/#events-are-serial",
            "text": "ReactiveSwift guarantees that all events upon a stream will arrive serially. In other\nwords, it\u2019s impossible for the observer of a signal or producer to receive\nmultiple  Event s concurrently, even if the events are sent on multiple threads\nsimultaneously.  This simplifies  operator  implementations and  observers .",
            "title": "Events are serial"
        },
        {
            "location": "/swift/reactive-swift/#events-are-never-delivered-recursively-and-values-cannot-be-sent-recursively",
            "text": "Just like  the guarantee of events not being delivered\nconcurrently , it is also guaranteed that events would not be\ndelivered recursively. As a consequence,  operators  and  observers   do not  need to\nbe reentrant.  If a  value  event is sent upon a signal from a thread that is  already processing \na previous event from that signal, it would result in a deadlock. This is because\nrecursive signals are usually programmer error, and the determinacy of\na deadlock is preferable to nondeterministic race conditions.  Note that a terminal event is permitted to be sent recursively.  When a recursive signal is explicitly desired, the recursive event should be\ntime-shifted, with an operator like  delay , to ensure that it isn\u2019t sent from\nan already-running event handler.",
            "title": "Events are never delivered recursively, and values cannot be sent recursively."
        },
        {
            "location": "/swift/reactive-swift/#events-are-sent-synchronously-by-default",
            "text": "ReactiveSwift does not implicitly introduce concurrency or asynchrony.  Operators  that\naccept a  scheduler  may, but they must be explicitly invoked by the consumer of\nthe framework.  A \u201cvanilla\u201d signal or producer will send all of its events synchronously by\ndefault, meaning that the  observer  will be synchronously invoked for each event\nas it is sent, and that the underlying work will not resume until the event\nhandler finishes.  This is similar to how  NSNotificationCenter  or  UIControl  events are\ndistributed.",
            "title": "Events are sent synchronously by default"
        },
        {
            "location": "/swift/reactive-swift/#the-signal-contract",
            "text": "A  signal  is a stream of values that obeys  the  Event  contract .  Signal  is a reference type, because each signal has identity \u2014 in other words, each\nsignal has its own lifetime, and may eventually terminate. Once terminated,\na signal cannot be restarted.",
            "title": "The Signal contract"
        },
        {
            "location": "/swift/reactive-swift/#signals-start-work-when-instantiated",
            "text": "Signal.init  immediately executes the generator closure that is passed to it.\nThis means that side effects may occur even before the initializer returns.  It is also possible to send  events  before the initializer returns. However,\nsince it is impossible for any  observers  to be attached at this point, any\nevents sent this way cannot be received.",
            "title": "Signals start work when instantiated"
        },
        {
            "location": "/swift/reactive-swift/#observing-a-signal-does-not-have-side-effects",
            "text": "The work associated with a  Signal  does not start or stop when  observers  are\nadded or removed, so the  observe  method (or the cancellation thereof) never\nhas side effects.  A signal\u2019s side effects can only be stopped through  a terminating event , or by a silent disposal at the point that  the signal is neither publicly reachable nor being observed .",
            "title": "Observing a signal does not have side effects"
        },
        {
            "location": "/swift/reactive-swift/#all-observers-of-a-signal-see-the-same-events-in-the-same-order",
            "text": "Because  observation does not have side\neffects , a  Signal  never\ncustomizes events for different  observers . When an event is sent upon a signal,\nit will be  synchronously \ndistributed to all observers that are attached at that time, much like\nhow  NSNotificationCenter  sends notifications.  In other words, there are not different event \u201ctimelines\u201d per observer. All\nobservers effectively see the same stream of events.  There is one exception to this rule: adding an observer to a signal  after  it\nhas already terminated will result in exactly one interrupted \nevent sent to that specific observer.",
            "title": "All observers of a signal see the same events in the same order"
        },
        {
            "location": "/swift/reactive-swift/#a-signal-is-alive-as-long-as-it-is-publicly-reachable-or-is-being-observed",
            "text": "A  Signal  must be publicly retained for attaching new observers, but not\nnecessarily for keeping the stream of events alive. Moreover, a  Signal  retains\nitself as long as there is still an active observer.  In other words, if a  Signal  is neither publicly retained nor being observed,\nit would dispose of the signal resources silently.  Note that the input observer of a signal does not retain the signal itself.  Long-running side effects are recommended to be modeled as an observer to the\nsignal.",
            "title": "A signal is alive as long as it is publicly reachable or is being observed"
        },
        {
            "location": "/swift/reactive-swift/#terminating-events-dispose-of-signal-resources",
            "text": "When a terminating  event  is sent along a  Signal , all  observers  will be\nreleased, and any resources being used to generate events should be disposed of.  The easiest way to ensure proper resource cleanup is to return a  disposable \nfrom the generator closure, which will be disposed of when termination occurs.\nThe disposable should be responsible for releasing memory, closing file handles,\ncanceling network requests, or anything else that may have been associated with\nthe work being performed.",
            "title": "Terminating events dispose of signal resources"
        },
        {
            "location": "/swift/reactive-swift/#the-signalproducer-contract",
            "text": "A  signal producer  is like a \u201crecipe\u201d for creating signals . Signal producers do not do anything by themselves\u2014 work begins only\nwhen a signal is produced .  Since a signal producer is just a declaration of  how  to create signals, it is\na value type, and has no memory management to speak of.",
            "title": "The SignalProducer contract"
        },
        {
            "location": "/swift/reactive-swift/#signal-producers-start-work-on-demand-by-creating-signals",
            "text": "The  start  and  startWithSignal  methods each\nproduce a  Signal  (implicitly and explicitly, respectively). After\ninstantiating the signal, the closure that was passed to SignalProducer.init  will be executed, to start the flow\nof  events  after any observers have been attached.  Although the producer itself is not  really  responsible for the execution of\nwork, it\u2019s common to speak of \u201cstarting\u201d and \u201ccanceling\u201d a producer. These terms\nrefer to producing a  Signal  that will start work, and  disposing of that\nsignal  to stop work.  A producer can be started any number of times (including zero), and the work\nassociated with it will execute exactly that many times as well.",
            "title": "Signal producers start work on demand by creating signals"
        },
        {
            "location": "/swift/reactive-swift/#each-produced-signal-may-send-different-events-at-different-times",
            "text": "Because signal producers  start work on\ndemand , there may\nbe different  observers  associated with each execution, and those observers\nmay see completely different  event  timelines.  In other words, events are generated from scratch for each time the producer is\nstarted, and can be completely different (or in a completely different order)\nfrom other times the producer is started.  Nonetheless, each execution of a signal producer will follow  the  Event \ncontract .",
            "title": "Each produced signal may send different events at different times"
        },
        {
            "location": "/swift/reactive-swift/#signal-operators-can-be-lifted-to-apply-to-signal-producers",
            "text": "Due to the relationship between signals and signal producers, it is possible to\nautomatically promote any  operators  over one or more  Signal s to apply to\nthe same number of  SignalProducer s instead, using the  lift  method.  lift  will apply the behavior of the specified operator to each  Signal  that\nis  created when the signal producer is started .",
            "title": "Signal operators can be lifted to apply to signal producers"
        },
        {
            "location": "/swift/reactive-swift/#disposing-of-a-produced-signal-will-interrupt-it",
            "text": "When a producer is started using the  start  or startWithSignal  methods, a  Disposable  is\nautomatically created and passed back.  Disposing of this object will interrupt \nthe produced  Signal , thereby canceling outstanding work and sending an interrupted   event  to all  observers , and will also dispose of\neverything added to the  CompositeDisposable  in SignalProducer.init .  Note that disposing of one produced  Signal  will not affect other signals created\nby the same  SignalProducer .",
            "title": "Disposing of a produced signal will interrupt it"
        },
        {
            "location": "/swift/reactive-swift/#the-property-contract",
            "text": "A property is essentially a  Signal  which guarantees it has an initial value, and its latest value is always available for being read out.  All read-only property types should conform to  PropertyProtocol , while the mutable counterparts should conform to  MutablePropertyProtocol . ReactiveSwift includes two primitives that implement the contract:  Property  and  MutableProperty .",
            "title": "The Property contract."
        },
        {
            "location": "/swift/reactive-swift/#a-property-must-have-its-latest-value-sent-synchronously-accessible",
            "text": "A property must have its latest value cached or stored at any point of time. It must be synchronously accessible through  PropertyProtocol.value .  The  SignalProducer  of a property must replay the latest value before forwarding subsequent changes, and it may ensure that no race condition exists between the replaying and the setup of the forwarding.",
            "title": "A property must have its latest value sent synchronously accessible."
        },
        {
            "location": "/swift/reactive-swift/#events-must-be-synchronously-emitted-after-the-mutation-is-visible",
            "text": "A mutable property must emit its values and the  completed  event synchronously.  The observers of a property should always observe the same value from the signal and the producer as   PropertyProtocol.value . This implies that all observations are a  didSet  observer.",
            "title": "Events must be synchronously emitted after the mutation is visible."
        },
        {
            "location": "/swift/reactive-swift/#reentrancy-must-be-supported-for-reads",
            "text": "All properties must guarantee that observers reading  PropertyProtocol.value  would not deadlock.  In other words, if a mutable property type implements its own, or inherits a synchronization mechanism from its container, the synchronization generally should be reentrant due to the requirements of synchrony.",
            "title": "Reentrancy must be supported for reads."
        },
        {
            "location": "/swift/reactive-swift/#a-composed-property-does-not-have-a-side-effect-on-its-sources-and-does-not-own-its-lifetime",
            "text": "A composed property presents a transformed view of its sources. It should not have a side effect on them, as  observing a signal does not have side effects  either. This implies a composed property should never retain its sources, or otherwise the  completed  event emitted upon deinitialization would be influenced.  Moreover, it does not own its lifetime, and its deinitialization should not affect its signal and its producer. The signal and the producer should respect the lifetime of the ultimate sources in a property composition graph.",
            "title": "A composed property does not have a side effect on its sources, and does not own its lifetime."
        },
        {
            "location": "/swift/reactive-swift/#best-practices",
            "text": "The following recommendations are intended to help keep ReactiveSwift-based code\npredictable, understandable, and performant.  They are, however, only guidelines. Use best judgement when determining whether\nto apply the recommendations here to a given piece of code.",
            "title": "Best practices"
        },
        {
            "location": "/swift/reactive-swift/#process-only-as-many-values-as-needed",
            "text": "Keeping an event stream alive longer than necessary can waste CPU and memory, as\nunnecessary work is performed for results that will never be used.  If only a certain number of values or certain number of time is required from\na  signal  or  producer , operators like take  or  takeUntil  can be used to\nautomatically complete the stream once a certain condition is fulfilled.  The benefit is exponential, too, as this will terminate dependent operators\nsooner, potentially saving a significant amount of work.",
            "title": "Process only as many values as needed"
        },
        {
            "location": "/swift/reactive-swift/#observe-events-on-a-known-scheduler",
            "text": "When receiving a  signal  or  producer  from unknown\ncode, it can be difficult to know which thread  events  will arrive upon. Although\nevents are  guaranteed to be serial , sometimes stronger\nguarantees are needed, like when performing UI updates (which must occur on the\nmain thread).  Whenever such a guarantee is important, the  observeOn  operator  should be used to force events to be received upon\na specific  scheduler .",
            "title": "Observe events on a known scheduler"
        },
        {
            "location": "/swift/reactive-swift/#switch-schedulers-in-as-few-places-as-possible",
            "text": "Notwithstanding the  above ,  events \nshould only be delivered to a specific  scheduler  when absolutely\nnecessary. Switching schedulers can introduce unnecessary delays and cause an\nincrease in CPU load.  Generally,  observeOn  should only be used right before observing\nthe  signal , starting the  producer , or binding to\na  property . This ensures that events arrive on the expected\nscheduler, without introducing multiple thread hops before their arrival.",
            "title": "Switch schedulers in as few places as possible"
        },
        {
            "location": "/swift/reactive-swift/#capture-side-effects-within-signal-producers",
            "text": "Because  signal producers start work on\ndemand , any\nfunctions or methods that return a  signal producer  should\nmake sure that side effects are captured  within  the producer itself, instead\nof being part of the function or method call.  For example, a function like this:  func search(text: String) -> SignalProducer<Result, NetworkError>  \u2026 should  not  immediately start a search.  Instead, the returned producer should execute the search once for every time\nthat it is started. This also means that if the producer is never started,\na search will never have to be performed either.",
            "title": "Capture side effects within signal producers"
        },
        {
            "location": "/swift/reactive-swift/#share-the-side-effects-of-a-signal-producer-by-sharing-one-produced-signal",
            "text": "If multiple  observers  are interested in the results of a  signal\nproducer , calling  start  once for each observer\nmeans that the work associated with the producer will  execute that many\ntimes  and  may not\ngenerate the same results .  If:   the observers need to receive the exact same results  the observers know about each other, or  the code starting the producer knows about each observer   \u2026 it may be more appropriate to start the producer  just once , and share the\nresults of that one  signal  to all observers, by attaching them within\nthe closure passed to the  startWithSignal  method.",
            "title": "Share the side effects of a signal producer by sharing one produced signal"
        },
        {
            "location": "/swift/reactive-swift/#prefer-managing-lifetime-with-operators-over-explicit-disposal",
            "text": "Although the  disposable  returned from  start  makes\ncanceling a  signal producer  really easy, explicit use of\ndisposables can quickly lead to a rat's nest of resource management and cleanup\ncode.  There are almost always higher-level  operators  that can be used instead of manual\ndisposal:   take  can be used to automatically terminate a stream once a certain\n   number of values have been received.  takeUntil  can be used to automatically terminate\n   a  signal  or producer when an event occurs (for example, when\n   a \u201cCancel\u201d button is pressed in the UI).  Properties  and the  <~  operator can be used to \u201cbind\u201d the result of\n   a signal or producer, until termination or until the property is deallocated.\n   This can replace a manual observation that sets a value somewhere.",
            "title": "Prefer managing lifetime with operators over explicit disposal"
        },
        {
            "location": "/swift/reactive-swift/#implementing-new-operators",
            "text": "ReactiveSwift provides a long list of built-in  operators  that should cover most use\ncases; however, ReactiveSwift is not a closed system. It's entirely valid to implement\nadditional operators for specialized uses, or for consideration in ReactiveSwift\nitself.  Implementing a new operator requires a careful attention to detail and a focus\non simplicity, to avoid introducing bugs into the calling code.  These guidelines cover some of the common pitfalls and help preserve the\nexpected API contracts. It may also help to look at the implementations of\nexisting  Signal  and  SignalProducer  operators for reference points.",
            "title": "Implementing new operators"
        },
        {
            "location": "/swift/reactive-swift/#prefer-writing-operators-that-apply-to-both-signals-and-producers",
            "text": "Since any  signal operator can apply to signal\nproducers ,\nwriting custom operators in terms of  Signal  means that SignalProducer  will get it \u201cfor free.\u201d  Even if the caller only needs to apply the new operator to signal producers at\nfirst, this generality can save time and effort in the future.  Of course, some capabilities  require  producers (for example, any retrying or\nrepeating), so it may not always be possible to write a signal-based version\ninstead.",
            "title": "Prefer writing operators that apply to both signals and producers"
        },
        {
            "location": "/swift/reactive-swift/#compose-existing-operators-when-possible",
            "text": "Considerable thought has been put into the operators provided by ReactiveSwift, and they\nhave been validated through automated tests and through their real world use in\nother projects. An operator that has been written from scratch may not be as\nrobust, or might not handle a special case that the built-in operators are aware\nof.  To minimize duplication and possible bugs, use the provided operators as much as\npossible in a custom operator implementation. Generally, there should be very\nlittle code written from scratch.",
            "title": "Compose existing operators when possible"
        },
        {
            "location": "/swift/reactive-swift/#forward-failure-and-interruption-events-as-soon-as-possible",
            "text": "Unless an operator is specifically built to handle failures  and interruptions \nin a custom way, it should propagate those events to the observer as soon as\npossible, to ensure that their semantics are honored.",
            "title": "Forward failure and interruption events as soon as possible"
        },
        {
            "location": "/swift/reactive-swift/#switch-over-event-values",
            "text": "Create your own  observer  to process raw  Event  values, and use\na  switch  statement to determine the event type.  For example:  producer.start { event in\n    switch event {\n    case let .Next(value):\n        print(\"Next event: \\(value)\")\n\n    case let .Failed(error):\n        print(\"Failed event: \\(error)\")\n\n    case .Completed:\n        print(\"Completed event\")\n\n    case .Interrupted:\n        print(\"Interrupted event\")\n    }\n}  Since the compiler will generate a warning if the  switch  is missing any case,\nthis prevents mistakes in a custom operator\u2019s event handling.",
            "title": "Switch over Event values"
        },
        {
            "location": "/swift/reactive-swift/#avoid-introducing-concurrency",
            "text": "Concurrency is an extremely common source of bugs in programming. To minimize\nthe potential for deadlocks and race conditions, operators should not\nconcurrently perform their work.  Callers always have the ability to  observe events on a specific\nscheduler , and ReactiveSwift offers built-in ways\nto parallelize work, so custom operators don\u2019t need to be concerned with it.",
            "title": "Avoid introducing concurrency"
        },
        {
            "location": "/swift/reactive-swift/#avoid-blocking-in-operators",
            "text": "Signal or producer operators should return a new signal or producer\n(respectively) as quickly as possible. Any work that the operator needs to\nperform should be part of the event handling logic,  not  part of the operator\ninvocation itself.  This guideline can be safely ignored when the purpose of an operator is to\nsynchronously retrieve one or more values from a stream, like  single()  or wait() .",
            "title": "Avoid blocking in operators"
        },
        {
            "location": "/about/",
            "text": "About?\n\n\nAbout!",
            "title": "About"
        },
        {
            "location": "/about/#about",
            "text": "",
            "title": "About?"
        },
        {
            "location": "/about/#about_1",
            "text": "",
            "title": "About!"
        }
    ]
}